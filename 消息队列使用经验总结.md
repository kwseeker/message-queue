# 消息队列使用经验总结

what when where who why how



消息队列是什么？为什么要用消息队列？项目中为何选择用消息队列而不是多线程实现异步？使用异步处理复杂业务有什么问题？引入消息队列中间件可能导致什么问题？引入消息队列中间件的高可用问题怎么解决？那么多消息队列中间件都什么区别怎么做选型？



**１）为什么用消息队列？**

因为**业务场景变复杂**了，比如我们项目中用户服务新增管理员用户往数据库插入管理员用户信息后，还需要设置权限，需要绑定公司，设置可用的服务功能等等。**单线程处理肯定性能不行**，需要做**异步处理**（做异步解决了性能但是也挖了坑，TODO）。



**２）实现异步为何不用多线程用消息队列？**

使用线程实现异步，对于我们微服务项目，首先要在这个代码注入一堆各个微服务远程调用的客户端，例如Feign客户端，耦合严重。然后每次添加拓展接口都要新增加代码然后重新部署；

但是使用消息队列，只需要完成新增管理员用户后，往消息队列发送一个消息说：管理员用户插入成功；其他操作的子微服务只需要监听这个消息即可，接到消息后从消息中获取管理员uid,再执行后续多个操作。



**３）复杂业务异步处理带来了啥坑？**

+ **后续操作有部分操作失败怎么办？**

  使用分布式事务控制整个业务。

  

**４）如何使用消息队列实现一条消息多消费者消费的？**



**５）引入消息队列中间件可能导致什么问题？**

+ **重复消费**

  当某条消息对应多个消费者的时候，如果某个消费者处理异常，抛出异常并要求重发一次；那么其他执行正常的消费者会再次接收到这个消息，再处理一次，这样就是重复消费。

  这是接口幂等问题，可以通过记录流水表（记录这次操作的唯一ID），在每次处理前先做校验。

  另外针对不重要的业务可以使用Redis实现流水表，将操作的唯一ID存储到Redis, 超时时间根据场景设置。

+ **消息丢失**

  

+ **顺序消费**

  以RocketMQ为例，使用MessageQueueSelector选择Hash取模的分发规则将有先后顺序的多个消息发送到同一个队列中，比如对一个订单是多个操作，但是拥有同一个订单ID, 对同一个订单ID Hash取模选择的是同一个队列。但是这种方式只是保证了顺序发送，同时还要求消费者对队列消息的消费是顺序的，才能保证顺序消费。

  比较稳妥的方式是一个消息发送并消费成功后再发送下一个消息。

  

**６）消息队列高可用如何保证？**

使用高可用集群部署。



## 附注

+ 淘宝的所有接口要求RT（ResponseTime）在200ms以内。

  